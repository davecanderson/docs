import{_ as e,o as t,c as a,a as s}from"./app.2aea72c0.js";const k=`{"title":"GitHub Action Docker Compose deployments via SSH","description":"","frontmatter":{"title":"GitHub Action Docker Compose deployments via SSH"},"headers":[{"level":2,"title":"ServiceStack GitHub Action Deployments","slug":"servicestack-github-action-deployments"},{"level":2,"title":"Overview","slug":"overview"},{"level":2,"title":"What's the process of release.yml?","slug":"what-s-the-process-of-release-yml"},{"level":2,"title":"Deployment server setup","slug":"deployment-server-setup"},{"level":3,"title":"GitHub Actions secrets","slug":"github-actions-secrets"},{"level":2,"title":"Deployments","slug":"deployments"},{"level":2,"title":"Pushing updates and rollbacks","slug":"pushing-updates-and-rollbacks"}],"relativePath":"ssh-github-action-deployment.md"}`,n={},o=s(`<p>This guide takes you through configuring your GitHub repo for SSH and CDN deployments that&#39;s configured in most <a href="https://servicestack.net/start" target="_blank" rel="noopener noreferrer">ServiceStack Project Templates</a> which triggers GitHub Action on commit that builds a dockerized .NET App using the template&#39;s included <strong>Dockerfile</strong> and publishes it to GitHub&#39;s Container Registry (ghcr) before deploying it via SSH to a vanilla Linux Server running Docker Compose.</p><h2 id="servicestack-github-action-deployments" tabindex="-1">ServiceStack GitHub Action Deployments <a class="header-anchor" href="#servicestack-github-action-deployments" aria-hidden="true">#</a></h2><p>The <a href="https://github.com/NetCoreTemplates/vue-mjs/blob/main/.github/workflows/release.yml" target="_blank" rel="noopener noreferrer">release.yml</a> in project templates enables GitHub Actions CI deployment to a dedicated server with SSH access.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-hidden="true">#</a></h2><p><code>release.yml</code> is designed to work with a ServiceStack app deploying directly to a single server via SSH. A docker image is built and stored on GitHub&#39;s <code>ghcr.io</code> docker registry when a GitHub Release is created.</p><p>GitHub Actions specified in <code>release.yml</code> then copy files remotely via scp and use <code>docker-compose</code> to run the app remotely via SSH.</p><h2 id="what-s-the-process-of-release-yml" tabindex="-1">What&#39;s the process of <code>release.yml</code>? <a class="header-anchor" href="#what-s-the-process-of-release-yml" aria-hidden="true">#</a></h2><p><img src="https://raw.githubusercontent.com/ServiceStack/docs/master/docs/images/mix/release-ghr-vanilla-diagram.png" alt=""></p><h2 id="deployment-server-setup" tabindex="-1">Deployment server setup <a class="header-anchor" href="#deployment-server-setup" aria-hidden="true">#</a></h2><p>To get this working, a server needs to be setup with the following:</p><ul><li>SSH access</li><li>docker</li><li>docker-compose</li><li>ports 443 and 80 for web access of your hosted application</li></ul><p>This can be your own server or any cloud hosted server like Digital Ocean, AWS, Azure etc. We use <a href="http://cloud.hetzner.com/" target="_blank" rel="noopener noreferrer">Hetzner Cloud</a> to deploy all ServiceStack&#39;s <a href="https://github.com/NetCoreTemplates/" target="_blank" rel="noopener noreferrer">GitHub Project Templates</a> as it was the <a href="https://servicestack.net/blog/finding-best-us-value-cloud-provider" target="_blank" rel="noopener noreferrer">best value US cloud provider</a> we&#39;ve found.</p><p>When setting up your server, you&#39;ll want to use a dedicated SSH key for access to be used by GitHub Actions. GitHub Actions will need the <em>private</em> SSH key within a GitHub Secret to authenticate. This can be done via ssh-keygen and copying the public key to the authorized clients on the server.</p><p>To let your server handle multiple ServiceStack applications and automate the generation and management of TLS certificates, an additional docker-compose file is provided in the template, <code>nginx-proxy-compose.yml</code>. This docker-compose file is ready to run and can be copied to the deployment server.</p><p>For example, once copied to remote <code>~/nginx-proxy-compose.yml</code>, the following command can be run on the remote server.</p><div class="language-bash"><pre><code><span class="token function">docker-compose</span> <span class="token parameter variable">-f</span> ~/nginx-proxy-compose.yml up <span class="token parameter variable">-d</span>
</code></pre></div><p>This will run an nginx reverse proxy along with a companion container that will watch for additional containers in the same docker network and attempt to initialize them with valid TLS certificates.</p><h3 id="github-actions-secrets" tabindex="-1">GitHub Actions secrets <a class="header-anchor" href="#github-actions-secrets" aria-hidden="true">#</a></h3><p>The <code>release.yml</code> assumes 4 secrets have been set:</p><table><thead><tr><th>Required Secrets</th><th>Description</th></tr></thead><tbody><tr><td><code>DEPLOY_HOST</code></td><td>Hostname used to SSH deploy .NET App to, this can either be an IP address or subdomain with A record pointing to the server</td></tr><tr><td><code>DEPLOY_USERNAME</code></td><td>Username to log in with via SSH e.g, <strong>ubuntu</strong>, <strong>ec2-user</strong>, <strong>root</strong></td></tr><tr><td><code>DEPLOY_KEY</code></td><td>SSH private key used to remotely access deploy .NET App</td></tr><tr><td><code>LETSENCRYPT_EMAIL</code></td><td>Email required for Let&#39;s Encrypt automated TLS certificates</td></tr></tbody></table><p>These secrets can use the <a href="https://cli.github.com/manual/gh_secret_set" target="_blank" rel="noopener noreferrer">GitHub CLI</a> for ease of creation. Eg, using the GitHub CLI the following can be set.</p><div class="language-bash"><pre><code>gh secret <span class="token builtin class-name">set</span> DEPLOY_HOST -b<span class="token string">&quot;&lt;DEPLOY_HOST&gt;&quot;</span>
gh secret <span class="token builtin class-name">set</span> DEPLOY_USERNAME -b<span class="token string">&quot;&lt;DEPLOY_USERNAME&gt;&quot;</span>
gh secret <span class="token builtin class-name">set</span> DEPLOY_KEY <span class="token operator">&lt;</span> key.pem <span class="token comment"># DEPLOY_KEY</span>
gh secret <span class="token builtin class-name">set</span> LETSENCRYPT_EMAIL -b<span class="token string">&quot;&lt;LETSENCRYPT_EMAIL&gt;&quot;</span>
</code></pre></div><p>These secrets are used to populate variables within GitHub Actions and other configuration files.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The <code>release.yml</code> process successfully creates your GitHub Container Repository for your project using the built-in permissions and <code>secrets.GITHUB_TOKEN</code>, if you are using previous versions of the template that use Personal Access Tokens (<code>CR_PAT</code>), you can <a href="https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-ghcrio" target="_blank" rel="noopener noreferrer">upgrade the workflow to use GITHUB_TOKEN</a> replacing the <code>CR_PAT</code>.</p></div><h2 id="deployments" tabindex="-1">Deployments <a class="header-anchor" href="#deployments" aria-hidden="true">#</a></h2><p>A published version of your .NET App created with the standard dotnet publish tool:</p><div class="language-bash"><pre><code>dotnet publish <span class="token parameter variable">-c</span> Release
</code></pre></div><p>is used to build a production build of your .NET App inside the standard <code>Dockerfile</code> for dockerizing .NET Applications.</p><p>Additional custom deployment tasks can be added to your project&#39;s package.json <strong>postinstall</strong> script which also gets run at deployment.</p><p>If preferred additional MS Build tasks can be run by passing in custom parameters in the publish command, e.g:</p><div class="language-bash"><pre><code>dotnet publish <span class="token parameter variable">-c</span> Release /p:APP_TASKS<span class="token operator">=</span>prerender
</code></pre></div><p>Which your <code>MyApp.csproj</code> can detect with a target that checks for it:</p><div class="language-xml"><pre><code><span class="token comment">&lt;!-- Prerender tasks run in release.yml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>AppTasks<span class="token punctuation">&quot;</span></span> <span class="token attr-name">AfterTargets</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Build<span class="token punctuation">&quot;</span></span> <span class="token attr-name">Condition</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$(APP_TASKS) != &#39;&#39;<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CallTarget</span> <span class="token attr-name">Targets</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">Condition</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$(APP_TASKS.Contains(&#39;prerender&#39;))<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Prerender<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Message</span> <span class="token attr-name">Text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Prerender...<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="pushing-updates-and-rollbacks" tabindex="-1">Pushing updates and rollbacks <a class="header-anchor" href="#pushing-updates-and-rollbacks" aria-hidden="true">#</a></h2><p>By default, deployments occur on commit to your main branch. A new Docker image for your ServiceStack API is produced, pushed to <a href="http://GHCR.io" target="_blank" rel="noopener noreferrer">GHCR.io</a> and hosted on your Linux server with Docker Compose.</p><p>The template also will run the release process on the creation of a GitHub Release making it easier to switch to manual production releases.</p><p>Additionally, the <code>release.yml</code> workflow can be run manually specifying a version. This enables production rollbacks based on previously tagged releases. A release must have already been created for the rollback build to work, it doesn&#39;t create a new Docker build based on previous code state, only redeploys as existing Docker image.</p>`,37),r=[o];function i(p,c,l,u,d,h){return t(),a("div",null,r)}var m=e(n,[["render",i]]);export{k as __pageData,m as default};
